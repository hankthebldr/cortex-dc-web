"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@firebase+functions@0.11.8_@firebase+app@0.10.13";
exports.ids = ["vendor-chunks/@firebase+functions@0.11.8_@firebase+app@0.10.13"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/@firebase+functions@0.11.8_@firebase+app@0.10.13/node_modules/@firebase/functions/dist/esm-node/index.node.esm.js":
/*!**************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@firebase+functions@0.11.8_@firebase+app@0.10.13/node_modules/@firebase/functions/dist/esm-node/index.node.esm.js ***!
  \**************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   connectFunctionsEmulator: () => (/* binding */ connectFunctionsEmulator),\n/* harmony export */   getFunctions: () => (/* binding */ getFunctions),\n/* harmony export */   httpsCallable: () => (/* binding */ httpsCallable),\n/* harmony export */   httpsCallableFromURL: () => (/* binding */ httpsCallableFromURL)\n/* harmony export */ });\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/app */ \"(ssr)/../../node_modules/.pnpm/@firebase+app@0.10.13/node_modules/@firebase/app/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/../../node_modules/.pnpm/@firebase+util@1.10.0/node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/component */ \"(ssr)/../../node_modules/.pnpm/@firebase+component@0.6.9/node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var undici__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! undici */ \"(ssr)/../../node_modules/.pnpm/undici@6.19.7/node_modules/undici/index.js\");\n\n\n\n\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LONG_TYPE = 'type.googleapis.com/google.protobuf.Int64Value';\r\nconst UNSIGNED_LONG_TYPE = 'type.googleapis.com/google.protobuf.UInt64Value';\r\nfunction mapValues(\r\n// { [k: string]: unknown } is no longer a wildcard assignment target after typescript 3.5\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\no, f) {\r\n    const result = {};\r\n    for (const key in o) {\r\n        if (o.hasOwnProperty(key)) {\r\n            result[key] = f(o[key]);\r\n        }\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Takes data and encodes it in a JSON-friendly way, such that types such as\r\n * Date are preserved.\r\n * @internal\r\n * @param data - Data to encode.\r\n */\r\nfunction encode(data) {\r\n    if (data == null) {\r\n        return null;\r\n    }\r\n    if (data instanceof Number) {\r\n        data = data.valueOf();\r\n    }\r\n    if (typeof data === 'number' && isFinite(data)) {\r\n        // Any number in JS is safe to put directly in JSON and parse as a double\r\n        // without any loss of precision.\r\n        return data;\r\n    }\r\n    if (data === true || data === false) {\r\n        return data;\r\n    }\r\n    if (Object.prototype.toString.call(data) === '[object String]') {\r\n        return data;\r\n    }\r\n    if (data instanceof Date) {\r\n        return data.toISOString();\r\n    }\r\n    if (Array.isArray(data)) {\r\n        return data.map(x => encode(x));\r\n    }\r\n    if (typeof data === 'function' || typeof data === 'object') {\r\n        return mapValues(data, x => encode(x));\r\n    }\r\n    // If we got this far, the data is not encodable.\r\n    throw new Error('Data cannot be encoded in JSON: ' + data);\r\n}\r\n/**\r\n * Takes data that's been encoded in a JSON-friendly form and returns a form\r\n * with richer datatypes, such as Dates, etc.\r\n * @internal\r\n * @param json - JSON to convert.\r\n */\r\nfunction decode(json) {\r\n    if (json == null) {\r\n        return json;\r\n    }\r\n    if (json['@type']) {\r\n        switch (json['@type']) {\r\n            case LONG_TYPE:\r\n            // Fall through and handle this the same as unsigned.\r\n            case UNSIGNED_LONG_TYPE: {\r\n                // Technically, this could work return a valid number for malformed\r\n                // data if there was a number followed by garbage. But it's just not\r\n                // worth all the extra code to detect that case.\r\n                const value = Number(json['value']);\r\n                if (isNaN(value)) {\r\n                    throw new Error('Data cannot be decoded from JSON: ' + json);\r\n                }\r\n                return value;\r\n            }\r\n            default: {\r\n                throw new Error('Data cannot be decoded from JSON: ' + json);\r\n            }\r\n        }\r\n    }\r\n    if (Array.isArray(json)) {\r\n        return json.map(x => decode(x));\r\n    }\r\n    if (typeof json === 'function' || typeof json === 'object') {\r\n        return mapValues(json, x => decode(x));\r\n    }\r\n    // Anything else is safe to return.\r\n    return json;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Type constant for Firebase Functions.\r\n */\r\nconst FUNCTIONS_TYPE = 'functions';\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Standard error codes for different ways a request can fail, as defined by:\r\n * https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto\r\n *\r\n * This map is used primarily to convert from a backend error code string to\r\n * a client SDK error code string, and make sure it's in the supported set.\r\n */\r\nconst errorCodeMap = {\r\n    OK: 'ok',\r\n    CANCELLED: 'cancelled',\r\n    UNKNOWN: 'unknown',\r\n    INVALID_ARGUMENT: 'invalid-argument',\r\n    DEADLINE_EXCEEDED: 'deadline-exceeded',\r\n    NOT_FOUND: 'not-found',\r\n    ALREADY_EXISTS: 'already-exists',\r\n    PERMISSION_DENIED: 'permission-denied',\r\n    UNAUTHENTICATED: 'unauthenticated',\r\n    RESOURCE_EXHAUSTED: 'resource-exhausted',\r\n    FAILED_PRECONDITION: 'failed-precondition',\r\n    ABORTED: 'aborted',\r\n    OUT_OF_RANGE: 'out-of-range',\r\n    UNIMPLEMENTED: 'unimplemented',\r\n    INTERNAL: 'internal',\r\n    UNAVAILABLE: 'unavailable',\r\n    DATA_LOSS: 'data-loss'\r\n};\r\n/**\r\n * An explicit error that can be thrown from a handler to send an error to the\r\n * client that called the function.\r\n */\r\nclass FunctionsError extends _firebase_util__WEBPACK_IMPORTED_MODULE_1__.FirebaseError {\r\n    constructor(\r\n    /**\r\n     * A standard error code that will be returned to the client. This also\r\n     * determines the HTTP status code of the response, as defined in code.proto.\r\n     */\r\n    code, message, \r\n    /**\r\n     * Extra data to be converted to JSON and included in the error response.\r\n     */\r\n    details) {\r\n        super(`${FUNCTIONS_TYPE}/${code}`, message || '');\r\n        this.details = details;\r\n    }\r\n}\r\n/**\r\n * Takes an HTTP status code and returns the corresponding ErrorCode.\r\n * This is the standard HTTP status code -> error mapping defined in:\r\n * https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto\r\n *\r\n * @param status An HTTP status code.\r\n * @return The corresponding ErrorCode, or ErrorCode.UNKNOWN if none.\r\n */\r\nfunction codeForHTTPStatus(status) {\r\n    // Make sure any successful status is OK.\r\n    if (status >= 200 && status < 300) {\r\n        return 'ok';\r\n    }\r\n    switch (status) {\r\n        case 0:\r\n            // This can happen if the server returns 500.\r\n            return 'internal';\r\n        case 400:\r\n            return 'invalid-argument';\r\n        case 401:\r\n            return 'unauthenticated';\r\n        case 403:\r\n            return 'permission-denied';\r\n        case 404:\r\n            return 'not-found';\r\n        case 409:\r\n            return 'aborted';\r\n        case 429:\r\n            return 'resource-exhausted';\r\n        case 499:\r\n            return 'cancelled';\r\n        case 500:\r\n            return 'internal';\r\n        case 501:\r\n            return 'unimplemented';\r\n        case 503:\r\n            return 'unavailable';\r\n        case 504:\r\n            return 'deadline-exceeded';\r\n    }\r\n    return 'unknown';\r\n}\r\n/**\r\n * Takes an HTTP response and returns the corresponding Error, if any.\r\n */\r\nfunction _errorForResponse(status, bodyJSON) {\r\n    let code = codeForHTTPStatus(status);\r\n    // Start with reasonable defaults from the status code.\r\n    let description = code;\r\n    let details = undefined;\r\n    // Then look through the body for explicit details.\r\n    try {\r\n        const errorJSON = bodyJSON && bodyJSON.error;\r\n        if (errorJSON) {\r\n            const status = errorJSON.status;\r\n            if (typeof status === 'string') {\r\n                if (!errorCodeMap[status]) {\r\n                    // They must've included an unknown error code in the body.\r\n                    return new FunctionsError('internal', 'internal');\r\n                }\r\n                code = errorCodeMap[status];\r\n                // TODO(klimt): Add better default descriptions for error enums.\r\n                // The default description needs to be updated for the new code.\r\n                description = status;\r\n            }\r\n            const message = errorJSON.message;\r\n            if (typeof message === 'string') {\r\n                description = message;\r\n            }\r\n            details = errorJSON.details;\r\n            if (details !== undefined) {\r\n                details = decode(details);\r\n            }\r\n        }\r\n    }\r\n    catch (e) {\r\n        // If we couldn't parse explicit error data, that's fine.\r\n    }\r\n    if (code === 'ok') {\r\n        // Technically, there's an edge case where a developer could explicitly\r\n        // return an error code of OK, and we will treat it as success, but that\r\n        // seems reasonable.\r\n        return null;\r\n    }\r\n    return new FunctionsError(code, description, details);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Helper class to get metadata that should be included with a function call.\r\n * @internal\r\n */\r\nclass ContextProvider {\r\n    constructor(authProvider, messagingProvider, appCheckProvider) {\r\n        this.auth = null;\r\n        this.messaging = null;\r\n        this.appCheck = null;\r\n        this.auth = authProvider.getImmediate({ optional: true });\r\n        this.messaging = messagingProvider.getImmediate({\r\n            optional: true\r\n        });\r\n        if (!this.auth) {\r\n            authProvider.get().then(auth => (this.auth = auth), () => {\r\n                /* get() never rejects */\r\n            });\r\n        }\r\n        if (!this.messaging) {\r\n            messagingProvider.get().then(messaging => (this.messaging = messaging), () => {\r\n                /* get() never rejects */\r\n            });\r\n        }\r\n        if (!this.appCheck) {\r\n            appCheckProvider.get().then(appCheck => (this.appCheck = appCheck), () => {\r\n                /* get() never rejects */\r\n            });\r\n        }\r\n    }\r\n    async getAuthToken() {\r\n        if (!this.auth) {\r\n            return undefined;\r\n        }\r\n        try {\r\n            const token = await this.auth.getToken();\r\n            return token === null || token === void 0 ? void 0 : token.accessToken;\r\n        }\r\n        catch (e) {\r\n            // If there's any error when trying to get the auth token, leave it off.\r\n            return undefined;\r\n        }\r\n    }\r\n    async getMessagingToken() {\r\n        if (!this.messaging ||\r\n            !('Notification' in self) ||\r\n            Notification.permission !== 'granted') {\r\n            return undefined;\r\n        }\r\n        try {\r\n            return await this.messaging.getToken();\r\n        }\r\n        catch (e) {\r\n            // We don't warn on this, because it usually means messaging isn't set up.\r\n            // console.warn('Failed to retrieve instance id token.', e);\r\n            // If there's any error when trying to get the token, leave it off.\r\n            return undefined;\r\n        }\r\n    }\r\n    async getAppCheckToken(limitedUseAppCheckTokens) {\r\n        if (this.appCheck) {\r\n            const result = limitedUseAppCheckTokens\r\n                ? await this.appCheck.getLimitedUseToken()\r\n                : await this.appCheck.getToken();\r\n            if (result.error) {\r\n                // Do not send the App Check header to the functions endpoint if\r\n                // there was an error from the App Check exchange endpoint. The App\r\n                // Check SDK will already have logged the error to console.\r\n                return null;\r\n            }\r\n            return result.token;\r\n        }\r\n        return null;\r\n    }\r\n    async getContext(limitedUseAppCheckTokens) {\r\n        const authToken = await this.getAuthToken();\r\n        const messagingToken = await this.getMessagingToken();\r\n        const appCheckToken = await this.getAppCheckToken(limitedUseAppCheckTokens);\r\n        return { authToken, messagingToken, appCheckToken };\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst DEFAULT_REGION = 'us-central1';\r\n/**\r\n * Returns a Promise that will be rejected after the given duration.\r\n * The error will be of type FunctionsError.\r\n *\r\n * @param millis Number of milliseconds to wait before rejecting.\r\n */\r\nfunction failAfter(millis) {\r\n    // Node timers and browser timers are fundamentally incompatible, but we\r\n    // don't care about the value here\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    let timer = null;\r\n    return {\r\n        promise: new Promise((_, reject) => {\r\n            timer = setTimeout(() => {\r\n                reject(new FunctionsError('deadline-exceeded', 'deadline-exceeded'));\r\n            }, millis);\r\n        }),\r\n        cancel: () => {\r\n            if (timer) {\r\n                clearTimeout(timer);\r\n            }\r\n        }\r\n    };\r\n}\r\n/**\r\n * The main class for the Firebase Functions SDK.\r\n * @internal\r\n */\r\nclass FunctionsService {\r\n    /**\r\n     * Creates a new Functions service for the given app.\r\n     * @param app - The FirebaseApp to use.\r\n     */\r\n    constructor(app, authProvider, messagingProvider, appCheckProvider, regionOrCustomDomain = DEFAULT_REGION, fetchImpl) {\r\n        this.app = app;\r\n        this.fetchImpl = fetchImpl;\r\n        this.emulatorOrigin = null;\r\n        this.contextProvider = new ContextProvider(authProvider, messagingProvider, appCheckProvider);\r\n        // Cancels all ongoing requests when resolved.\r\n        this.cancelAllRequests = new Promise(resolve => {\r\n            this.deleteService = () => {\r\n                return Promise.resolve(resolve());\r\n            };\r\n        });\r\n        // Resolve the region or custom domain overload by attempting to parse it.\r\n        try {\r\n            const url = new URL(regionOrCustomDomain);\r\n            this.customDomain =\r\n                url.origin + (url.pathname === '/' ? '' : url.pathname);\r\n            this.region = DEFAULT_REGION;\r\n        }\r\n        catch (e) {\r\n            this.customDomain = null;\r\n            this.region = regionOrCustomDomain;\r\n        }\r\n    }\r\n    _delete() {\r\n        return this.deleteService();\r\n    }\r\n    /**\r\n     * Returns the URL for a callable with the given name.\r\n     * @param name - The name of the callable.\r\n     * @internal\r\n     */\r\n    _url(name) {\r\n        const projectId = this.app.options.projectId;\r\n        if (this.emulatorOrigin !== null) {\r\n            const origin = this.emulatorOrigin;\r\n            return `${origin}/${projectId}/${this.region}/${name}`;\r\n        }\r\n        if (this.customDomain !== null) {\r\n            return `${this.customDomain}/${name}`;\r\n        }\r\n        return `https://${this.region}-${projectId}.cloudfunctions.net/${name}`;\r\n    }\r\n}\r\n/**\r\n * Modify this instance to communicate with the Cloud Functions emulator.\r\n *\r\n * Note: this must be called before this instance has been used to do any operations.\r\n *\r\n * @param host The emulator host (ex: localhost)\r\n * @param port The emulator port (ex: 5001)\r\n * @public\r\n */\r\nfunction connectFunctionsEmulator$1(functionsInstance, host, port) {\r\n    functionsInstance.emulatorOrigin = `http://${host}:${port}`;\r\n}\r\n/**\r\n * Returns a reference to the callable https trigger with the given name.\r\n * @param name - The name of the trigger.\r\n * @public\r\n */\r\nfunction httpsCallable$1(functionsInstance, name, options) {\r\n    return (data => {\r\n        return call(functionsInstance, name, data, options || {});\r\n    });\r\n}\r\n/**\r\n * Returns a reference to the callable https trigger with the given url.\r\n * @param url - The url of the trigger.\r\n * @public\r\n */\r\nfunction httpsCallableFromURL$1(functionsInstance, url, options) {\r\n    return (data => {\r\n        return callAtURL(functionsInstance, url, data, options || {});\r\n    });\r\n}\r\n/**\r\n * Does an HTTP POST and returns the completed response.\r\n * @param url The url to post to.\r\n * @param body The JSON body of the post.\r\n * @param headers The HTTP headers to include in the request.\r\n * @return A Promise that will succeed when the request finishes.\r\n */\r\nasync function postJSON(url, body, headers, fetchImpl) {\r\n    headers['Content-Type'] = 'application/json';\r\n    let response;\r\n    try {\r\n        response = await fetchImpl(url, {\r\n            method: 'POST',\r\n            body: JSON.stringify(body),\r\n            headers\r\n        });\r\n    }\r\n    catch (e) {\r\n        // This could be an unhandled error on the backend, or it could be a\r\n        // network error. There's no way to know, since an unhandled error on the\r\n        // backend will fail to set the proper CORS header, and thus will be\r\n        // treated as a network error by fetch.\r\n        return {\r\n            status: 0,\r\n            json: null\r\n        };\r\n    }\r\n    let json = null;\r\n    try {\r\n        json = await response.json();\r\n    }\r\n    catch (e) {\r\n        // If we fail to parse JSON, it will fail the same as an empty body.\r\n    }\r\n    return {\r\n        status: response.status,\r\n        json\r\n    };\r\n}\r\n/**\r\n * Calls a callable function asynchronously and returns the result.\r\n * @param name The name of the callable trigger.\r\n * @param data The data to pass as params to the function.s\r\n */\r\nfunction call(functionsInstance, name, data, options) {\r\n    const url = functionsInstance._url(name);\r\n    return callAtURL(functionsInstance, url, data, options);\r\n}\r\n/**\r\n * Calls a callable function asynchronously and returns the result.\r\n * @param url The url of the callable trigger.\r\n * @param data The data to pass as params to the function.s\r\n */\r\nasync function callAtURL(functionsInstance, url, data, options) {\r\n    // Encode any special types, such as dates, in the input data.\r\n    data = encode(data);\r\n    const body = { data };\r\n    // Add a header for the authToken.\r\n    const headers = {};\r\n    const context = await functionsInstance.contextProvider.getContext(options.limitedUseAppCheckTokens);\r\n    if (context.authToken) {\r\n        headers['Authorization'] = 'Bearer ' + context.authToken;\r\n    }\r\n    if (context.messagingToken) {\r\n        headers['Firebase-Instance-ID-Token'] = context.messagingToken;\r\n    }\r\n    if (context.appCheckToken !== null) {\r\n        headers['X-Firebase-AppCheck'] = context.appCheckToken;\r\n    }\r\n    // Default timeout to 70s, but let the options override it.\r\n    const timeout = options.timeout || 70000;\r\n    const failAfterHandle = failAfter(timeout);\r\n    const response = await Promise.race([\r\n        postJSON(url, body, headers, functionsInstance.fetchImpl),\r\n        failAfterHandle.promise,\r\n        functionsInstance.cancelAllRequests\r\n    ]);\r\n    // Always clear the failAfter timeout\r\n    failAfterHandle.cancel();\r\n    // If service was deleted, interrupted response throws an error.\r\n    if (!response) {\r\n        throw new FunctionsError('cancelled', 'Firebase Functions instance was deleted.');\r\n    }\r\n    // Check for an error status, regardless of http status.\r\n    const error = _errorForResponse(response.status, response.json);\r\n    if (error) {\r\n        throw error;\r\n    }\r\n    if (!response.json) {\r\n        throw new FunctionsError('internal', 'Response is not valid JSON object.');\r\n    }\r\n    let responseData = response.json.data;\r\n    // TODO(klimt): For right now, allow \"result\" instead of \"data\", for\r\n    // backwards compatibility.\r\n    if (typeof responseData === 'undefined') {\r\n        responseData = response.json.result;\r\n    }\r\n    if (typeof responseData === 'undefined') {\r\n        // Consider the response malformed.\r\n        throw new FunctionsError('internal', 'Response is missing data field.');\r\n    }\r\n    // Decode any special types, such as dates, in the returned data.\r\n    const decodedData = decode(responseData);\r\n    return { data: decodedData };\r\n}\n\nconst name = \"@firebase/functions\";\nconst version = \"0.11.8\";\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst AUTH_INTERNAL_NAME = 'auth-internal';\r\nconst APP_CHECK_INTERNAL_NAME = 'app-check-internal';\r\nconst MESSAGING_INTERNAL_NAME = 'messaging-internal';\r\nfunction registerFunctions(fetchImpl, variant) {\r\n    const factory = (container, { instanceIdentifier: regionOrCustomDomain }) => {\r\n        // Dependencies\r\n        const app = container.getProvider('app').getImmediate();\r\n        const authProvider = container.getProvider(AUTH_INTERNAL_NAME);\r\n        const messagingProvider = container.getProvider(MESSAGING_INTERNAL_NAME);\r\n        const appCheckProvider = container.getProvider(APP_CHECK_INTERNAL_NAME);\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        return new FunctionsService(app, authProvider, messagingProvider, appCheckProvider, regionOrCustomDomain, fetchImpl);\r\n    };\r\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_2__.Component(FUNCTIONS_TYPE, factory, \"PUBLIC\" /* ComponentType.PUBLIC */).setMultipleInstances(true));\r\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version, variant);\r\n    // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\r\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version, 'esm2017');\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Returns a {@link Functions} instance for the given app.\r\n * @param app - The {@link @firebase/app#FirebaseApp} to use.\r\n * @param regionOrCustomDomain - one of:\r\n *   a) The region the callable functions are located in (ex: us-central1)\r\n *   b) A custom domain hosting the callable functions (ex: https://mydomain.com)\r\n * @public\r\n */\r\nfunction getFunctions(app = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApp)(), regionOrCustomDomain = DEFAULT_REGION) {\r\n    // Dependencies\r\n    const functionsProvider = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(app), FUNCTIONS_TYPE);\r\n    const functionsInstance = functionsProvider.getImmediate({\r\n        identifier: regionOrCustomDomain\r\n    });\r\n    const emulator = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getDefaultEmulatorHostnameAndPort)('functions');\r\n    if (emulator) {\r\n        connectFunctionsEmulator(functionsInstance, ...emulator);\r\n    }\r\n    return functionsInstance;\r\n}\r\n/**\r\n * Modify this instance to communicate with the Cloud Functions emulator.\r\n *\r\n * Note: this must be called before this instance has been used to do any operations.\r\n *\r\n * @param host - The emulator host (ex: localhost)\r\n * @param port - The emulator port (ex: 5001)\r\n * @public\r\n */\r\nfunction connectFunctionsEmulator(functionsInstance, host, port) {\r\n    connectFunctionsEmulator$1((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(functionsInstance), host, port);\r\n}\r\n/**\r\n * Returns a reference to the callable HTTPS trigger with the given name.\r\n * @param name - The name of the trigger.\r\n * @public\r\n */\r\nfunction httpsCallable(functionsInstance, name, options) {\r\n    return httpsCallable$1((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(functionsInstance), name, options);\r\n}\r\n/**\r\n * Returns a reference to the callable HTTPS trigger with the specified url.\r\n * @param url - The url of the trigger.\r\n * @public\r\n */\r\nfunction httpsCallableFromURL(functionsInstance, url, options) {\r\n    return httpsCallableFromURL$1((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(functionsInstance), url, options);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nregisterFunctions(undici__WEBPACK_IMPORTED_MODULE_3__.fetch, 'node');\n\n\n//# sourceMappingURL=index.node.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BmaXJlYmFzZStmdW5jdGlvbnNAMC4xMS44X0BmaXJlYmFzZSthcHBAMC4xMC4xMy9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2Z1bmN0aW9ucy9kaXN0L2VzbS1ub2RlL2luZGV4Lm5vZGUuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQTBGO0FBQ1k7QUFDdEQ7QUFDakI7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyx1QkFBdUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIseURBQWE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZUFBZSxHQUFHLEtBQUs7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxnQkFBZ0I7QUFDaEU7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU8sR0FBRyxVQUFVLEdBQUcsWUFBWSxHQUFHLEtBQUs7QUFDakU7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0IsR0FBRyxLQUFLO0FBQ2hEO0FBQ0EsMEJBQTBCLFlBQVksR0FBRyxVQUFVLHNCQUFzQixLQUFLO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxLQUFLLEdBQUcsS0FBSztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsMENBQTBDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlFQUFrQixLQUFLLDBEQUFTO0FBQ3BDLElBQUksOERBQWU7QUFDbkI7QUFDQSxJQUFJLDhEQUFlO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQixxQkFBcUIsaUNBQWlDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscURBQU07QUFDbEM7QUFDQSw4QkFBOEIsMkRBQVksQ0FBQyxrRUFBa0I7QUFDN0Q7QUFDQTtBQUNBLEtBQUs7QUFDTCxxQkFBcUIsaUZBQWlDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrRUFBa0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0VBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtFQUFrQjtBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlDQUFLOztBQUVnRTtBQUN2RiIsInNvdXJjZXMiOlsid2VicGFjazovL0Bjb3J0ZXgtZGMvd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AZmlyZWJhc2UrZnVuY3Rpb25zQDAuMTEuOF9AZmlyZWJhc2UrYXBwQDAuMTAuMTMvbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9mdW5jdGlvbnMvZGlzdC9lc20tbm9kZS9pbmRleC5ub2RlLmVzbS5qcz9iMzE3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9yZWdpc3RlckNvbXBvbmVudCwgcmVnaXN0ZXJWZXJzaW9uLCBfZ2V0UHJvdmlkZXIsIGdldEFwcCB9IGZyb20gJ0BmaXJlYmFzZS9hcHAnO1xuaW1wb3J0IHsgRmlyZWJhc2VFcnJvciwgZ2V0TW9kdWxhckluc3RhbmNlLCBnZXREZWZhdWx0RW11bGF0b3JIb3N0bmFtZUFuZFBvcnQgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAZmlyZWJhc2UvY29tcG9uZW50JztcbmltcG9ydCB7IGZldGNoIH0gZnJvbSAndW5kaWNpJztcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgTE9OR19UWVBFID0gJ3R5cGUuZ29vZ2xlYXBpcy5jb20vZ29vZ2xlLnByb3RvYnVmLkludDY0VmFsdWUnO1xyXG5jb25zdCBVTlNJR05FRF9MT05HX1RZUEUgPSAndHlwZS5nb29nbGVhcGlzLmNvbS9nb29nbGUucHJvdG9idWYuVUludDY0VmFsdWUnO1xyXG5mdW5jdGlvbiBtYXBWYWx1ZXMoXHJcbi8vIHsgW2s6IHN0cmluZ106IHVua25vd24gfSBpcyBubyBsb25nZXIgYSB3aWxkY2FyZCBhc3NpZ25tZW50IHRhcmdldCBhZnRlciB0eXBlc2NyaXB0IDMuNVxyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG5vLCBmKSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIG8pIHtcclxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gZihvW2tleV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLyoqXHJcbiAqIFRha2VzIGRhdGEgYW5kIGVuY29kZXMgaXQgaW4gYSBKU09OLWZyaWVuZGx5IHdheSwgc3VjaCB0aGF0IHR5cGVzIHN1Y2ggYXNcclxuICogRGF0ZSBhcmUgcHJlc2VydmVkLlxyXG4gKiBAaW50ZXJuYWxcclxuICogQHBhcmFtIGRhdGEgLSBEYXRhIHRvIGVuY29kZS5cclxuICovXHJcbmZ1bmN0aW9uIGVuY29kZShkYXRhKSB7XHJcbiAgICBpZiAoZGF0YSA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIE51bWJlcikge1xyXG4gICAgICAgIGRhdGEgPSBkYXRhLnZhbHVlT2YoKTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUoZGF0YSkpIHtcclxuICAgICAgICAvLyBBbnkgbnVtYmVyIGluIEpTIGlzIHNhZmUgdG8gcHV0IGRpcmVjdGx5IGluIEpTT04gYW5kIHBhcnNlIGFzIGEgZG91YmxlXHJcbiAgICAgICAgLy8gd2l0aG91dCBhbnkgbG9zcyBvZiBwcmVjaXNpb24uXHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9XHJcbiAgICBpZiAoZGF0YSA9PT0gdHJ1ZSB8fCBkYXRhID09PSBmYWxzZSkge1xyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfVxyXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgU3RyaW5nXScpIHtcclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgRGF0ZSkge1xyXG4gICAgICAgIHJldHVybiBkYXRhLnRvSVNPU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xyXG4gICAgICAgIHJldHVybiBkYXRhLm1hcCh4ID0+IGVuY29kZSh4KSk7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgcmV0dXJuIG1hcFZhbHVlcyhkYXRhLCB4ID0+IGVuY29kZSh4KSk7XHJcbiAgICB9XHJcbiAgICAvLyBJZiB3ZSBnb3QgdGhpcyBmYXIsIHRoZSBkYXRhIGlzIG5vdCBlbmNvZGFibGUuXHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgY2Fubm90IGJlIGVuY29kZWQgaW4gSlNPTjogJyArIGRhdGEpO1xyXG59XHJcbi8qKlxyXG4gKiBUYWtlcyBkYXRhIHRoYXQncyBiZWVuIGVuY29kZWQgaW4gYSBKU09OLWZyaWVuZGx5IGZvcm0gYW5kIHJldHVybnMgYSBmb3JtXHJcbiAqIHdpdGggcmljaGVyIGRhdGF0eXBlcywgc3VjaCBhcyBEYXRlcywgZXRjLlxyXG4gKiBAaW50ZXJuYWxcclxuICogQHBhcmFtIGpzb24gLSBKU09OIHRvIGNvbnZlcnQuXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWNvZGUoanNvbikge1xyXG4gICAgaWYgKGpzb24gPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBqc29uO1xyXG4gICAgfVxyXG4gICAgaWYgKGpzb25bJ0B0eXBlJ10pIHtcclxuICAgICAgICBzd2l0Y2ggKGpzb25bJ0B0eXBlJ10pIHtcclxuICAgICAgICAgICAgY2FzZSBMT05HX1RZUEU6XHJcbiAgICAgICAgICAgIC8vIEZhbGwgdGhyb3VnaCBhbmQgaGFuZGxlIHRoaXMgdGhlIHNhbWUgYXMgdW5zaWduZWQuXHJcbiAgICAgICAgICAgIGNhc2UgVU5TSUdORURfTE9OR19UWVBFOiB7XHJcbiAgICAgICAgICAgICAgICAvLyBUZWNobmljYWxseSwgdGhpcyBjb3VsZCB3b3JrIHJldHVybiBhIHZhbGlkIG51bWJlciBmb3IgbWFsZm9ybWVkXHJcbiAgICAgICAgICAgICAgICAvLyBkYXRhIGlmIHRoZXJlIHdhcyBhIG51bWJlciBmb2xsb3dlZCBieSBnYXJiYWdlLiBCdXQgaXQncyBqdXN0IG5vdFxyXG4gICAgICAgICAgICAgICAgLy8gd29ydGggYWxsIHRoZSBleHRyYSBjb2RlIHRvIGRldGVjdCB0aGF0IGNhc2UuXHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IE51bWJlcihqc29uWyd2YWx1ZSddKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgY2Fubm90IGJlIGRlY29kZWQgZnJvbSBKU09OOiAnICsganNvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVmYXVsdDoge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIGNhbm5vdCBiZSBkZWNvZGVkIGZyb20gSlNPTjogJyArIGpzb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoanNvbikpIHtcclxuICAgICAgICByZXR1cm4ganNvbi5tYXAoeCA9PiBkZWNvZGUoeCkpO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBqc29uID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBqc29uID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIHJldHVybiBtYXBWYWx1ZXMoanNvbiwgeCA9PiBkZWNvZGUoeCkpO1xyXG4gICAgfVxyXG4gICAgLy8gQW55dGhpbmcgZWxzZSBpcyBzYWZlIHRvIHJldHVybi5cclxuICAgIHJldHVybiBqc29uO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBUeXBlIGNvbnN0YW50IGZvciBGaXJlYmFzZSBGdW5jdGlvbnMuXHJcbiAqL1xyXG5jb25zdCBGVU5DVElPTlNfVFlQRSA9ICdmdW5jdGlvbnMnO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogU3RhbmRhcmQgZXJyb3IgY29kZXMgZm9yIGRpZmZlcmVudCB3YXlzIGEgcmVxdWVzdCBjYW4gZmFpbCwgYXMgZGVmaW5lZCBieTpcclxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZWFwaXMvZ29vZ2xlYXBpcy9ibG9iL21hc3Rlci9nb29nbGUvcnBjL2NvZGUucHJvdG9cclxuICpcclxuICogVGhpcyBtYXAgaXMgdXNlZCBwcmltYXJpbHkgdG8gY29udmVydCBmcm9tIGEgYmFja2VuZCBlcnJvciBjb2RlIHN0cmluZyB0b1xyXG4gKiBhIGNsaWVudCBTREsgZXJyb3IgY29kZSBzdHJpbmcsIGFuZCBtYWtlIHN1cmUgaXQncyBpbiB0aGUgc3VwcG9ydGVkIHNldC5cclxuICovXHJcbmNvbnN0IGVycm9yQ29kZU1hcCA9IHtcclxuICAgIE9LOiAnb2snLFxyXG4gICAgQ0FOQ0VMTEVEOiAnY2FuY2VsbGVkJyxcclxuICAgIFVOS05PV046ICd1bmtub3duJyxcclxuICAgIElOVkFMSURfQVJHVU1FTlQ6ICdpbnZhbGlkLWFyZ3VtZW50JyxcclxuICAgIERFQURMSU5FX0VYQ0VFREVEOiAnZGVhZGxpbmUtZXhjZWVkZWQnLFxyXG4gICAgTk9UX0ZPVU5EOiAnbm90LWZvdW5kJyxcclxuICAgIEFMUkVBRFlfRVhJU1RTOiAnYWxyZWFkeS1leGlzdHMnLFxyXG4gICAgUEVSTUlTU0lPTl9ERU5JRUQ6ICdwZXJtaXNzaW9uLWRlbmllZCcsXHJcbiAgICBVTkFVVEhFTlRJQ0FURUQ6ICd1bmF1dGhlbnRpY2F0ZWQnLFxyXG4gICAgUkVTT1VSQ0VfRVhIQVVTVEVEOiAncmVzb3VyY2UtZXhoYXVzdGVkJyxcclxuICAgIEZBSUxFRF9QUkVDT05ESVRJT046ICdmYWlsZWQtcHJlY29uZGl0aW9uJyxcclxuICAgIEFCT1JURUQ6ICdhYm9ydGVkJyxcclxuICAgIE9VVF9PRl9SQU5HRTogJ291dC1vZi1yYW5nZScsXHJcbiAgICBVTklNUExFTUVOVEVEOiAndW5pbXBsZW1lbnRlZCcsXHJcbiAgICBJTlRFUk5BTDogJ2ludGVybmFsJyxcclxuICAgIFVOQVZBSUxBQkxFOiAndW5hdmFpbGFibGUnLFxyXG4gICAgREFUQV9MT1NTOiAnZGF0YS1sb3NzJ1xyXG59O1xyXG4vKipcclxuICogQW4gZXhwbGljaXQgZXJyb3IgdGhhdCBjYW4gYmUgdGhyb3duIGZyb20gYSBoYW5kbGVyIHRvIHNlbmQgYW4gZXJyb3IgdG8gdGhlXHJcbiAqIGNsaWVudCB0aGF0IGNhbGxlZCB0aGUgZnVuY3Rpb24uXHJcbiAqL1xyXG5jbGFzcyBGdW5jdGlvbnNFcnJvciBleHRlbmRzIEZpcmViYXNlRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKipcclxuICAgICAqIEEgc3RhbmRhcmQgZXJyb3IgY29kZSB0aGF0IHdpbGwgYmUgcmV0dXJuZWQgdG8gdGhlIGNsaWVudC4gVGhpcyBhbHNvXHJcbiAgICAgKiBkZXRlcm1pbmVzIHRoZSBIVFRQIHN0YXR1cyBjb2RlIG9mIHRoZSByZXNwb25zZSwgYXMgZGVmaW5lZCBpbiBjb2RlLnByb3RvLlxyXG4gICAgICovXHJcbiAgICBjb2RlLCBtZXNzYWdlLCBcclxuICAgIC8qKlxyXG4gICAgICogRXh0cmEgZGF0YSB0byBiZSBjb252ZXJ0ZWQgdG8gSlNPTiBhbmQgaW5jbHVkZWQgaW4gdGhlIGVycm9yIHJlc3BvbnNlLlxyXG4gICAgICovXHJcbiAgICBkZXRhaWxzKSB7XHJcbiAgICAgICAgc3VwZXIoYCR7RlVOQ1RJT05TX1RZUEV9LyR7Y29kZX1gLCBtZXNzYWdlIHx8ICcnKTtcclxuICAgICAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUYWtlcyBhbiBIVFRQIHN0YXR1cyBjb2RlIGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIEVycm9yQ29kZS5cclxuICogVGhpcyBpcyB0aGUgc3RhbmRhcmQgSFRUUCBzdGF0dXMgY29kZSAtPiBlcnJvciBtYXBwaW5nIGRlZmluZWQgaW46XHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGVhcGlzL2dvb2dsZWFwaXMvYmxvYi9tYXN0ZXIvZ29vZ2xlL3JwYy9jb2RlLnByb3RvXHJcbiAqXHJcbiAqIEBwYXJhbSBzdGF0dXMgQW4gSFRUUCBzdGF0dXMgY29kZS5cclxuICogQHJldHVybiBUaGUgY29ycmVzcG9uZGluZyBFcnJvckNvZGUsIG9yIEVycm9yQ29kZS5VTktOT1dOIGlmIG5vbmUuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb2RlRm9ySFRUUFN0YXR1cyhzdGF0dXMpIHtcclxuICAgIC8vIE1ha2Ugc3VyZSBhbnkgc3VjY2Vzc2Z1bCBzdGF0dXMgaXMgT0suXHJcbiAgICBpZiAoc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDApIHtcclxuICAgICAgICByZXR1cm4gJ29rJztcclxuICAgIH1cclxuICAgIHN3aXRjaCAoc3RhdHVzKSB7XHJcbiAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgdGhlIHNlcnZlciByZXR1cm5zIDUwMC5cclxuICAgICAgICAgICAgcmV0dXJuICdpbnRlcm5hbCc7XHJcbiAgICAgICAgY2FzZSA0MDA6XHJcbiAgICAgICAgICAgIHJldHVybiAnaW52YWxpZC1hcmd1bWVudCc7XHJcbiAgICAgICAgY2FzZSA0MDE6XHJcbiAgICAgICAgICAgIHJldHVybiAndW5hdXRoZW50aWNhdGVkJztcclxuICAgICAgICBjYXNlIDQwMzpcclxuICAgICAgICAgICAgcmV0dXJuICdwZXJtaXNzaW9uLWRlbmllZCc7XHJcbiAgICAgICAgY2FzZSA0MDQ6XHJcbiAgICAgICAgICAgIHJldHVybiAnbm90LWZvdW5kJztcclxuICAgICAgICBjYXNlIDQwOTpcclxuICAgICAgICAgICAgcmV0dXJuICdhYm9ydGVkJztcclxuICAgICAgICBjYXNlIDQyOTpcclxuICAgICAgICAgICAgcmV0dXJuICdyZXNvdXJjZS1leGhhdXN0ZWQnO1xyXG4gICAgICAgIGNhc2UgNDk5OlxyXG4gICAgICAgICAgICByZXR1cm4gJ2NhbmNlbGxlZCc7XHJcbiAgICAgICAgY2FzZSA1MDA6XHJcbiAgICAgICAgICAgIHJldHVybiAnaW50ZXJuYWwnO1xyXG4gICAgICAgIGNhc2UgNTAxOlxyXG4gICAgICAgICAgICByZXR1cm4gJ3VuaW1wbGVtZW50ZWQnO1xyXG4gICAgICAgIGNhc2UgNTAzOlxyXG4gICAgICAgICAgICByZXR1cm4gJ3VuYXZhaWxhYmxlJztcclxuICAgICAgICBjYXNlIDUwNDpcclxuICAgICAgICAgICAgcmV0dXJuICdkZWFkbGluZS1leGNlZWRlZCc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gJ3Vua25vd24nO1xyXG59XHJcbi8qKlxyXG4gKiBUYWtlcyBhbiBIVFRQIHJlc3BvbnNlIGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIEVycm9yLCBpZiBhbnkuXHJcbiAqL1xyXG5mdW5jdGlvbiBfZXJyb3JGb3JSZXNwb25zZShzdGF0dXMsIGJvZHlKU09OKSB7XHJcbiAgICBsZXQgY29kZSA9IGNvZGVGb3JIVFRQU3RhdHVzKHN0YXR1cyk7XHJcbiAgICAvLyBTdGFydCB3aXRoIHJlYXNvbmFibGUgZGVmYXVsdHMgZnJvbSB0aGUgc3RhdHVzIGNvZGUuXHJcbiAgICBsZXQgZGVzY3JpcHRpb24gPSBjb2RlO1xyXG4gICAgbGV0IGRldGFpbHMgPSB1bmRlZmluZWQ7XHJcbiAgICAvLyBUaGVuIGxvb2sgdGhyb3VnaCB0aGUgYm9keSBmb3IgZXhwbGljaXQgZGV0YWlscy5cclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3JKU09OID0gYm9keUpTT04gJiYgYm9keUpTT04uZXJyb3I7XHJcbiAgICAgICAgaWYgKGVycm9ySlNPTikge1xyXG4gICAgICAgICAgICBjb25zdCBzdGF0dXMgPSBlcnJvckpTT04uc3RhdHVzO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0YXR1cyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIGlmICghZXJyb3JDb2RlTWFwW3N0YXR1c10pIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGV5IG11c3QndmUgaW5jbHVkZWQgYW4gdW5rbm93biBlcnJvciBjb2RlIGluIHRoZSBib2R5LlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25zRXJyb3IoJ2ludGVybmFsJywgJ2ludGVybmFsJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb2RlID0gZXJyb3JDb2RlTWFwW3N0YXR1c107XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPKGtsaW10KTogQWRkIGJldHRlciBkZWZhdWx0IGRlc2NyaXB0aW9ucyBmb3IgZXJyb3IgZW51bXMuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCBkZXNjcmlwdGlvbiBuZWVkcyB0byBiZSB1cGRhdGVkIGZvciB0aGUgbmV3IGNvZGUuXHJcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbiA9IHN0YXR1cztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gZXJyb3JKU09OLm1lc3NhZ2U7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uID0gbWVzc2FnZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZXRhaWxzID0gZXJyb3JKU09OLmRldGFpbHM7XHJcbiAgICAgICAgICAgIGlmIChkZXRhaWxzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGRldGFpbHMgPSBkZWNvZGUoZGV0YWlscyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIC8vIElmIHdlIGNvdWxkbid0IHBhcnNlIGV4cGxpY2l0IGVycm9yIGRhdGEsIHRoYXQncyBmaW5lLlxyXG4gICAgfVxyXG4gICAgaWYgKGNvZGUgPT09ICdvaycpIHtcclxuICAgICAgICAvLyBUZWNobmljYWxseSwgdGhlcmUncyBhbiBlZGdlIGNhc2Ugd2hlcmUgYSBkZXZlbG9wZXIgY291bGQgZXhwbGljaXRseVxyXG4gICAgICAgIC8vIHJldHVybiBhbiBlcnJvciBjb2RlIG9mIE9LLCBhbmQgd2Ugd2lsbCB0cmVhdCBpdCBhcyBzdWNjZXNzLCBidXQgdGhhdFxyXG4gICAgICAgIC8vIHNlZW1zIHJlYXNvbmFibGUuXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uc0Vycm9yKGNvZGUsIGRlc2NyaXB0aW9uLCBkZXRhaWxzKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogSGVscGVyIGNsYXNzIHRvIGdldCBtZXRhZGF0YSB0aGF0IHNob3VsZCBiZSBpbmNsdWRlZCB3aXRoIGEgZnVuY3Rpb24gY2FsbC5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jbGFzcyBDb250ZXh0UHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3IoYXV0aFByb3ZpZGVyLCBtZXNzYWdpbmdQcm92aWRlciwgYXBwQ2hlY2tQcm92aWRlcikge1xyXG4gICAgICAgIHRoaXMuYXV0aCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5tZXNzYWdpbmcgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYXBwQ2hlY2sgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYXV0aCA9IGF1dGhQcm92aWRlci5nZXRJbW1lZGlhdGUoeyBvcHRpb25hbDogdHJ1ZSB9KTtcclxuICAgICAgICB0aGlzLm1lc3NhZ2luZyA9IG1lc3NhZ2luZ1Byb3ZpZGVyLmdldEltbWVkaWF0ZSh7XHJcbiAgICAgICAgICAgIG9wdGlvbmFsOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKCF0aGlzLmF1dGgpIHtcclxuICAgICAgICAgICAgYXV0aFByb3ZpZGVyLmdldCgpLnRoZW4oYXV0aCA9PiAodGhpcy5hdXRoID0gYXV0aCksICgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8qIGdldCgpIG5ldmVyIHJlamVjdHMgKi9cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5tZXNzYWdpbmcpIHtcclxuICAgICAgICAgICAgbWVzc2FnaW5nUHJvdmlkZXIuZ2V0KCkudGhlbihtZXNzYWdpbmcgPT4gKHRoaXMubWVzc2FnaW5nID0gbWVzc2FnaW5nKSwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLyogZ2V0KCkgbmV2ZXIgcmVqZWN0cyAqL1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLmFwcENoZWNrKSB7XHJcbiAgICAgICAgICAgIGFwcENoZWNrUHJvdmlkZXIuZ2V0KCkudGhlbihhcHBDaGVjayA9PiAodGhpcy5hcHBDaGVjayA9IGFwcENoZWNrKSwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLyogZ2V0KCkgbmV2ZXIgcmVqZWN0cyAqL1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhc3luYyBnZXRBdXRoVG9rZW4oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmF1dGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSBhd2FpdCB0aGlzLmF1dGguZ2V0VG9rZW4oKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRva2VuID09PSBudWxsIHx8IHRva2VuID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0b2tlbi5hY2Nlc3NUb2tlbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhbnkgZXJyb3Igd2hlbiB0cnlpbmcgdG8gZ2V0IHRoZSBhdXRoIHRva2VuLCBsZWF2ZSBpdCBvZmYuXHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYXN5bmMgZ2V0TWVzc2FnaW5nVG9rZW4oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLm1lc3NhZ2luZyB8fFxyXG4gICAgICAgICAgICAhKCdOb3RpZmljYXRpb24nIGluIHNlbGYpIHx8XHJcbiAgICAgICAgICAgIE5vdGlmaWNhdGlvbi5wZXJtaXNzaW9uICE9PSAnZ3JhbnRlZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubWVzc2FnaW5nLmdldFRva2VuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IHdhcm4gb24gdGhpcywgYmVjYXVzZSBpdCB1c3VhbGx5IG1lYW5zIG1lc3NhZ2luZyBpc24ndCBzZXQgdXAuXHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHJldHJpZXZlIGluc3RhbmNlIGlkIHRva2VuLicsIGUpO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGFueSBlcnJvciB3aGVuIHRyeWluZyB0byBnZXQgdGhlIHRva2VuLCBsZWF2ZSBpdCBvZmYuXHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYXN5bmMgZ2V0QXBwQ2hlY2tUb2tlbihsaW1pdGVkVXNlQXBwQ2hlY2tUb2tlbnMpIHtcclxuICAgICAgICBpZiAodGhpcy5hcHBDaGVjaykge1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBsaW1pdGVkVXNlQXBwQ2hlY2tUb2tlbnNcclxuICAgICAgICAgICAgICAgID8gYXdhaXQgdGhpcy5hcHBDaGVjay5nZXRMaW1pdGVkVXNlVG9rZW4oKVxyXG4gICAgICAgICAgICAgICAgOiBhd2FpdCB0aGlzLmFwcENoZWNrLmdldFRva2VuKCk7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIC8vIERvIG5vdCBzZW5kIHRoZSBBcHAgQ2hlY2sgaGVhZGVyIHRvIHRoZSBmdW5jdGlvbnMgZW5kcG9pbnQgaWZcclxuICAgICAgICAgICAgICAgIC8vIHRoZXJlIHdhcyBhbiBlcnJvciBmcm9tIHRoZSBBcHAgQ2hlY2sgZXhjaGFuZ2UgZW5kcG9pbnQuIFRoZSBBcHBcclxuICAgICAgICAgICAgICAgIC8vIENoZWNrIFNESyB3aWxsIGFscmVhZHkgaGF2ZSBsb2dnZWQgdGhlIGVycm9yIHRvIGNvbnNvbGUuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRva2VuO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGFzeW5jIGdldENvbnRleHQobGltaXRlZFVzZUFwcENoZWNrVG9rZW5zKSB7XHJcbiAgICAgICAgY29uc3QgYXV0aFRva2VuID0gYXdhaXQgdGhpcy5nZXRBdXRoVG9rZW4oKTtcclxuICAgICAgICBjb25zdCBtZXNzYWdpbmdUb2tlbiA9IGF3YWl0IHRoaXMuZ2V0TWVzc2FnaW5nVG9rZW4oKTtcclxuICAgICAgICBjb25zdCBhcHBDaGVja1Rva2VuID0gYXdhaXQgdGhpcy5nZXRBcHBDaGVja1Rva2VuKGxpbWl0ZWRVc2VBcHBDaGVja1Rva2Vucyk7XHJcbiAgICAgICAgcmV0dXJuIHsgYXV0aFRva2VuLCBtZXNzYWdpbmdUb2tlbiwgYXBwQ2hlY2tUb2tlbiB9O1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IERFRkFVTFRfUkVHSU9OID0gJ3VzLWNlbnRyYWwxJztcclxuLyoqXHJcbiAqIFJldHVybnMgYSBQcm9taXNlIHRoYXQgd2lsbCBiZSByZWplY3RlZCBhZnRlciB0aGUgZ2l2ZW4gZHVyYXRpb24uXHJcbiAqIFRoZSBlcnJvciB3aWxsIGJlIG9mIHR5cGUgRnVuY3Rpb25zRXJyb3IuXHJcbiAqXHJcbiAqIEBwYXJhbSBtaWxsaXMgTnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSByZWplY3RpbmcuXHJcbiAqL1xyXG5mdW5jdGlvbiBmYWlsQWZ0ZXIobWlsbGlzKSB7XHJcbiAgICAvLyBOb2RlIHRpbWVycyBhbmQgYnJvd3NlciB0aW1lcnMgYXJlIGZ1bmRhbWVudGFsbHkgaW5jb21wYXRpYmxlLCBidXQgd2VcclxuICAgIC8vIGRvbid0IGNhcmUgYWJvdXQgdGhlIHZhbHVlIGhlcmVcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICBsZXQgdGltZXIgPSBudWxsO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBwcm9taXNlOiBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEZ1bmN0aW9uc0Vycm9yKCdkZWFkbGluZS1leGNlZWRlZCcsICdkZWFkbGluZS1leGNlZWRlZCcpKTtcclxuICAgICAgICAgICAgfSwgbWlsbGlzKTtcclxuICAgICAgICB9KSxcclxuICAgICAgICBjYW5jZWw6ICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRpbWVyKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogVGhlIG1haW4gY2xhc3MgZm9yIHRoZSBGaXJlYmFzZSBGdW5jdGlvbnMgU0RLLlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNsYXNzIEZ1bmN0aW9uc1NlcnZpY2Uge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEZ1bmN0aW9ucyBzZXJ2aWNlIGZvciB0aGUgZ2l2ZW4gYXBwLlxyXG4gICAgICogQHBhcmFtIGFwcCAtIFRoZSBGaXJlYmFzZUFwcCB0byB1c2UuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGFwcCwgYXV0aFByb3ZpZGVyLCBtZXNzYWdpbmdQcm92aWRlciwgYXBwQ2hlY2tQcm92aWRlciwgcmVnaW9uT3JDdXN0b21Eb21haW4gPSBERUZBVUxUX1JFR0lPTiwgZmV0Y2hJbXBsKSB7XHJcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XHJcbiAgICAgICAgdGhpcy5mZXRjaEltcGwgPSBmZXRjaEltcGw7XHJcbiAgICAgICAgdGhpcy5lbXVsYXRvck9yaWdpbiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0UHJvdmlkZXIgPSBuZXcgQ29udGV4dFByb3ZpZGVyKGF1dGhQcm92aWRlciwgbWVzc2FnaW5nUHJvdmlkZXIsIGFwcENoZWNrUHJvdmlkZXIpO1xyXG4gICAgICAgIC8vIENhbmNlbHMgYWxsIG9uZ29pbmcgcmVxdWVzdHMgd2hlbiByZXNvbHZlZC5cclxuICAgICAgICB0aGlzLmNhbmNlbEFsbFJlcXVlc3RzID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlU2VydmljZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzb2x2ZSgpKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBSZXNvbHZlIHRoZSByZWdpb24gb3IgY3VzdG9tIGRvbWFpbiBvdmVybG9hZCBieSBhdHRlbXB0aW5nIHRvIHBhcnNlIGl0LlxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwocmVnaW9uT3JDdXN0b21Eb21haW4pO1xyXG4gICAgICAgICAgICB0aGlzLmN1c3RvbURvbWFpbiA9XHJcbiAgICAgICAgICAgICAgICB1cmwub3JpZ2luICsgKHVybC5wYXRobmFtZSA9PT0gJy8nID8gJycgOiB1cmwucGF0aG5hbWUpO1xyXG4gICAgICAgICAgICB0aGlzLnJlZ2lvbiA9IERFRkFVTFRfUkVHSU9OO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB0aGlzLmN1c3RvbURvbWFpbiA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMucmVnaW9uID0gcmVnaW9uT3JDdXN0b21Eb21haW47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2RlbGV0ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kZWxldGVTZXJ2aWNlKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIFVSTCBmb3IgYSBjYWxsYWJsZSB3aXRoIHRoZSBnaXZlbiBuYW1lLlxyXG4gICAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgY2FsbGFibGUuXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgX3VybChuYW1lKSB7XHJcbiAgICAgICAgY29uc3QgcHJvamVjdElkID0gdGhpcy5hcHAub3B0aW9ucy5wcm9qZWN0SWQ7XHJcbiAgICAgICAgaWYgKHRoaXMuZW11bGF0b3JPcmlnaW4gIT09IG51bGwpIHtcclxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luID0gdGhpcy5lbXVsYXRvck9yaWdpbjtcclxuICAgICAgICAgICAgcmV0dXJuIGAke29yaWdpbn0vJHtwcm9qZWN0SWR9LyR7dGhpcy5yZWdpb259LyR7bmFtZX1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jdXN0b21Eb21haW4gIT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMuY3VzdG9tRG9tYWlufS8ke25hbWV9YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGBodHRwczovLyR7dGhpcy5yZWdpb259LSR7cHJvamVjdElkfS5jbG91ZGZ1bmN0aW9ucy5uZXQvJHtuYW1lfWA7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIE1vZGlmeSB0aGlzIGluc3RhbmNlIHRvIGNvbW11bmljYXRlIHdpdGggdGhlIENsb3VkIEZ1bmN0aW9ucyBlbXVsYXRvci5cclxuICpcclxuICogTm90ZTogdGhpcyBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgdGhpcyBpbnN0YW5jZSBoYXMgYmVlbiB1c2VkIHRvIGRvIGFueSBvcGVyYXRpb25zLlxyXG4gKlxyXG4gKiBAcGFyYW0gaG9zdCBUaGUgZW11bGF0b3IgaG9zdCAoZXg6IGxvY2FsaG9zdClcclxuICogQHBhcmFtIHBvcnQgVGhlIGVtdWxhdG9yIHBvcnQgKGV4OiA1MDAxKVxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBjb25uZWN0RnVuY3Rpb25zRW11bGF0b3IkMShmdW5jdGlvbnNJbnN0YW5jZSwgaG9zdCwgcG9ydCkge1xyXG4gICAgZnVuY3Rpb25zSW5zdGFuY2UuZW11bGF0b3JPcmlnaW4gPSBgaHR0cDovLyR7aG9zdH06JHtwb3J0fWA7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGNhbGxhYmxlIGh0dHBzIHRyaWdnZXIgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cclxuICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgdHJpZ2dlci5cclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gaHR0cHNDYWxsYWJsZSQxKGZ1bmN0aW9uc0luc3RhbmNlLCBuYW1lLCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gKGRhdGEgPT4ge1xyXG4gICAgICAgIHJldHVybiBjYWxsKGZ1bmN0aW9uc0luc3RhbmNlLCBuYW1lLCBkYXRhLCBvcHRpb25zIHx8IHt9KTtcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBjYWxsYWJsZSBodHRwcyB0cmlnZ2VyIHdpdGggdGhlIGdpdmVuIHVybC5cclxuICogQHBhcmFtIHVybCAtIFRoZSB1cmwgb2YgdGhlIHRyaWdnZXIuXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGh0dHBzQ2FsbGFibGVGcm9tVVJMJDEoZnVuY3Rpb25zSW5zdGFuY2UsIHVybCwgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIChkYXRhID0+IHtcclxuICAgICAgICByZXR1cm4gY2FsbEF0VVJMKGZ1bmN0aW9uc0luc3RhbmNlLCB1cmwsIGRhdGEsIG9wdGlvbnMgfHwge30pO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIERvZXMgYW4gSFRUUCBQT1NUIGFuZCByZXR1cm5zIHRoZSBjb21wbGV0ZWQgcmVzcG9uc2UuXHJcbiAqIEBwYXJhbSB1cmwgVGhlIHVybCB0byBwb3N0IHRvLlxyXG4gKiBAcGFyYW0gYm9keSBUaGUgSlNPTiBib2R5IG9mIHRoZSBwb3N0LlxyXG4gKiBAcGFyYW0gaGVhZGVycyBUaGUgSFRUUCBoZWFkZXJzIHRvIGluY2x1ZGUgaW4gdGhlIHJlcXVlc3QuXHJcbiAqIEByZXR1cm4gQSBQcm9taXNlIHRoYXQgd2lsbCBzdWNjZWVkIHdoZW4gdGhlIHJlcXVlc3QgZmluaXNoZXMuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBwb3N0SlNPTih1cmwsIGJvZHksIGhlYWRlcnMsIGZldGNoSW1wbCkge1xyXG4gICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XHJcbiAgICBsZXQgcmVzcG9uc2U7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hJbXBsKHVybCwge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXHJcbiAgICAgICAgICAgIGhlYWRlcnNcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgLy8gVGhpcyBjb3VsZCBiZSBhbiB1bmhhbmRsZWQgZXJyb3Igb24gdGhlIGJhY2tlbmQsIG9yIGl0IGNvdWxkIGJlIGFcclxuICAgICAgICAvLyBuZXR3b3JrIGVycm9yLiBUaGVyZSdzIG5vIHdheSB0byBrbm93LCBzaW5jZSBhbiB1bmhhbmRsZWQgZXJyb3Igb24gdGhlXHJcbiAgICAgICAgLy8gYmFja2VuZCB3aWxsIGZhaWwgdG8gc2V0IHRoZSBwcm9wZXIgQ09SUyBoZWFkZXIsIGFuZCB0aHVzIHdpbGwgYmVcclxuICAgICAgICAvLyB0cmVhdGVkIGFzIGEgbmV0d29yayBlcnJvciBieSBmZXRjaC5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzdGF0dXM6IDAsXHJcbiAgICAgICAgICAgIGpzb246IG51bGxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgbGV0IGpzb24gPSBudWxsO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAvLyBJZiB3ZSBmYWlsIHRvIHBhcnNlIEpTT04sIGl0IHdpbGwgZmFpbCB0aGUgc2FtZSBhcyBhbiBlbXB0eSBib2R5LlxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcclxuICAgICAgICBqc29uXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBDYWxscyBhIGNhbGxhYmxlIGZ1bmN0aW9uIGFzeW5jaHJvbm91c2x5IGFuZCByZXR1cm5zIHRoZSByZXN1bHQuXHJcbiAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBjYWxsYWJsZSB0cmlnZ2VyLlxyXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBwYXNzIGFzIHBhcmFtcyB0byB0aGUgZnVuY3Rpb24uc1xyXG4gKi9cclxuZnVuY3Rpb24gY2FsbChmdW5jdGlvbnNJbnN0YW5jZSwgbmFtZSwgZGF0YSwgb3B0aW9ucykge1xyXG4gICAgY29uc3QgdXJsID0gZnVuY3Rpb25zSW5zdGFuY2UuX3VybChuYW1lKTtcclxuICAgIHJldHVybiBjYWxsQXRVUkwoZnVuY3Rpb25zSW5zdGFuY2UsIHVybCwgZGF0YSwgb3B0aW9ucyk7XHJcbn1cclxuLyoqXHJcbiAqIENhbGxzIGEgY2FsbGFibGUgZnVuY3Rpb24gYXN5bmNocm9ub3VzbHkgYW5kIHJldHVybnMgdGhlIHJlc3VsdC5cclxuICogQHBhcmFtIHVybCBUaGUgdXJsIG9mIHRoZSBjYWxsYWJsZSB0cmlnZ2VyLlxyXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBwYXNzIGFzIHBhcmFtcyB0byB0aGUgZnVuY3Rpb24uc1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gY2FsbEF0VVJMKGZ1bmN0aW9uc0luc3RhbmNlLCB1cmwsIGRhdGEsIG9wdGlvbnMpIHtcclxuICAgIC8vIEVuY29kZSBhbnkgc3BlY2lhbCB0eXBlcywgc3VjaCBhcyBkYXRlcywgaW4gdGhlIGlucHV0IGRhdGEuXHJcbiAgICBkYXRhID0gZW5jb2RlKGRhdGEpO1xyXG4gICAgY29uc3QgYm9keSA9IHsgZGF0YSB9O1xyXG4gICAgLy8gQWRkIGEgaGVhZGVyIGZvciB0aGUgYXV0aFRva2VuLlxyXG4gICAgY29uc3QgaGVhZGVycyA9IHt9O1xyXG4gICAgY29uc3QgY29udGV4dCA9IGF3YWl0IGZ1bmN0aW9uc0luc3RhbmNlLmNvbnRleHRQcm92aWRlci5nZXRDb250ZXh0KG9wdGlvbnMubGltaXRlZFVzZUFwcENoZWNrVG9rZW5zKTtcclxuICAgIGlmIChjb250ZXh0LmF1dGhUb2tlbikge1xyXG4gICAgICAgIGhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXSA9ICdCZWFyZXIgJyArIGNvbnRleHQuYXV0aFRva2VuO1xyXG4gICAgfVxyXG4gICAgaWYgKGNvbnRleHQubWVzc2FnaW5nVG9rZW4pIHtcclxuICAgICAgICBoZWFkZXJzWydGaXJlYmFzZS1JbnN0YW5jZS1JRC1Ub2tlbiddID0gY29udGV4dC5tZXNzYWdpbmdUb2tlbjtcclxuICAgIH1cclxuICAgIGlmIChjb250ZXh0LmFwcENoZWNrVG9rZW4gIT09IG51bGwpIHtcclxuICAgICAgICBoZWFkZXJzWydYLUZpcmViYXNlLUFwcENoZWNrJ10gPSBjb250ZXh0LmFwcENoZWNrVG9rZW47XHJcbiAgICB9XHJcbiAgICAvLyBEZWZhdWx0IHRpbWVvdXQgdG8gNzBzLCBidXQgbGV0IHRoZSBvcHRpb25zIG92ZXJyaWRlIGl0LlxyXG4gICAgY29uc3QgdGltZW91dCA9IG9wdGlvbnMudGltZW91dCB8fCA3MDAwMDtcclxuICAgIGNvbnN0IGZhaWxBZnRlckhhbmRsZSA9IGZhaWxBZnRlcih0aW1lb3V0KTtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtcclxuICAgICAgICBwb3N0SlNPTih1cmwsIGJvZHksIGhlYWRlcnMsIGZ1bmN0aW9uc0luc3RhbmNlLmZldGNoSW1wbCksXHJcbiAgICAgICAgZmFpbEFmdGVySGFuZGxlLnByb21pc2UsXHJcbiAgICAgICAgZnVuY3Rpb25zSW5zdGFuY2UuY2FuY2VsQWxsUmVxdWVzdHNcclxuICAgIF0pO1xyXG4gICAgLy8gQWx3YXlzIGNsZWFyIHRoZSBmYWlsQWZ0ZXIgdGltZW91dFxyXG4gICAgZmFpbEFmdGVySGFuZGxlLmNhbmNlbCgpO1xyXG4gICAgLy8gSWYgc2VydmljZSB3YXMgZGVsZXRlZCwgaW50ZXJydXB0ZWQgcmVzcG9uc2UgdGhyb3dzIGFuIGVycm9yLlxyXG4gICAgaWYgKCFyZXNwb25zZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBGdW5jdGlvbnNFcnJvcignY2FuY2VsbGVkJywgJ0ZpcmViYXNlIEZ1bmN0aW9ucyBpbnN0YW5jZSB3YXMgZGVsZXRlZC4nKTtcclxuICAgIH1cclxuICAgIC8vIENoZWNrIGZvciBhbiBlcnJvciBzdGF0dXMsIHJlZ2FyZGxlc3Mgb2YgaHR0cCBzdGF0dXMuXHJcbiAgICBjb25zdCBlcnJvciA9IF9lcnJvckZvclJlc3BvbnNlKHJlc3BvbnNlLnN0YXR1cywgcmVzcG9uc2UuanNvbik7XHJcbiAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICAgIGlmICghcmVzcG9uc2UuanNvbikge1xyXG4gICAgICAgIHRocm93IG5ldyBGdW5jdGlvbnNFcnJvcignaW50ZXJuYWwnLCAnUmVzcG9uc2UgaXMgbm90IHZhbGlkIEpTT04gb2JqZWN0LicpO1xyXG4gICAgfVxyXG4gICAgbGV0IHJlc3BvbnNlRGF0YSA9IHJlc3BvbnNlLmpzb24uZGF0YTtcclxuICAgIC8vIFRPRE8oa2xpbXQpOiBGb3IgcmlnaHQgbm93LCBhbGxvdyBcInJlc3VsdFwiIGluc3RlYWQgb2YgXCJkYXRhXCIsIGZvclxyXG4gICAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXHJcbiAgICBpZiAodHlwZW9mIHJlc3BvbnNlRGF0YSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXNwb25zZURhdGEgPSByZXNwb25zZS5qc29uLnJlc3VsdDtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgcmVzcG9uc2VEYXRhID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIC8vIENvbnNpZGVyIHRoZSByZXNwb25zZSBtYWxmb3JtZWQuXHJcbiAgICAgICAgdGhyb3cgbmV3IEZ1bmN0aW9uc0Vycm9yKCdpbnRlcm5hbCcsICdSZXNwb25zZSBpcyBtaXNzaW5nIGRhdGEgZmllbGQuJyk7XHJcbiAgICB9XHJcbiAgICAvLyBEZWNvZGUgYW55IHNwZWNpYWwgdHlwZXMsIHN1Y2ggYXMgZGF0ZXMsIGluIHRoZSByZXR1cm5lZCBkYXRhLlxyXG4gICAgY29uc3QgZGVjb2RlZERhdGEgPSBkZWNvZGUocmVzcG9uc2VEYXRhKTtcclxuICAgIHJldHVybiB7IGRhdGE6IGRlY29kZWREYXRhIH07XHJcbn1cblxuY29uc3QgbmFtZSA9IFwiQGZpcmViYXNlL2Z1bmN0aW9uc1wiO1xuY29uc3QgdmVyc2lvbiA9IFwiMC4xMS44XCI7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IEFVVEhfSU5URVJOQUxfTkFNRSA9ICdhdXRoLWludGVybmFsJztcclxuY29uc3QgQVBQX0NIRUNLX0lOVEVSTkFMX05BTUUgPSAnYXBwLWNoZWNrLWludGVybmFsJztcclxuY29uc3QgTUVTU0FHSU5HX0lOVEVSTkFMX05BTUUgPSAnbWVzc2FnaW5nLWludGVybmFsJztcclxuZnVuY3Rpb24gcmVnaXN0ZXJGdW5jdGlvbnMoZmV0Y2hJbXBsLCB2YXJpYW50KSB7XHJcbiAgICBjb25zdCBmYWN0b3J5ID0gKGNvbnRhaW5lciwgeyBpbnN0YW5jZUlkZW50aWZpZXI6IHJlZ2lvbk9yQ3VzdG9tRG9tYWluIH0pID0+IHtcclxuICAgICAgICAvLyBEZXBlbmRlbmNpZXNcclxuICAgICAgICBjb25zdCBhcHAgPSBjb250YWluZXIuZ2V0UHJvdmlkZXIoJ2FwcCcpLmdldEltbWVkaWF0ZSgpO1xyXG4gICAgICAgIGNvbnN0IGF1dGhQcm92aWRlciA9IGNvbnRhaW5lci5nZXRQcm92aWRlcihBVVRIX0lOVEVSTkFMX05BTUUpO1xyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2luZ1Byb3ZpZGVyID0gY29udGFpbmVyLmdldFByb3ZpZGVyKE1FU1NBR0lOR19JTlRFUk5BTF9OQU1FKTtcclxuICAgICAgICBjb25zdCBhcHBDaGVja1Byb3ZpZGVyID0gY29udGFpbmVyLmdldFByb3ZpZGVyKEFQUF9DSEVDS19JTlRFUk5BTF9OQU1FKTtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25zU2VydmljZShhcHAsIGF1dGhQcm92aWRlciwgbWVzc2FnaW5nUHJvdmlkZXIsIGFwcENoZWNrUHJvdmlkZXIsIHJlZ2lvbk9yQ3VzdG9tRG9tYWluLCBmZXRjaEltcGwpO1xyXG4gICAgfTtcclxuICAgIF9yZWdpc3RlckNvbXBvbmVudChuZXcgQ29tcG9uZW50KEZVTkNUSU9OU19UWVBFLCBmYWN0b3J5LCBcIlBVQkxJQ1wiIC8qIENvbXBvbmVudFR5cGUuUFVCTElDICovKS5zZXRNdWx0aXBsZUluc3RhbmNlcyh0cnVlKSk7XHJcbiAgICByZWdpc3RlclZlcnNpb24obmFtZSwgdmVyc2lvbiwgdmFyaWFudCk7XHJcbiAgICAvLyBCVUlMRF9UQVJHRVQgd2lsbCBiZSByZXBsYWNlZCBieSB2YWx1ZXMgbGlrZSBlc201LCBlc20yMDE3LCBjanM1LCBldGMgZHVyaW5nIHRoZSBjb21waWxhdGlvblxyXG4gICAgcmVnaXN0ZXJWZXJzaW9uKG5hbWUsIHZlcnNpb24sICdlc20yMDE3Jyk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFJldHVybnMgYSB7QGxpbmsgRnVuY3Rpb25zfSBpbnN0YW5jZSBmb3IgdGhlIGdpdmVuIGFwcC5cclxuICogQHBhcmFtIGFwcCAtIFRoZSB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZUFwcH0gdG8gdXNlLlxyXG4gKiBAcGFyYW0gcmVnaW9uT3JDdXN0b21Eb21haW4gLSBvbmUgb2Y6XHJcbiAqICAgYSkgVGhlIHJlZ2lvbiB0aGUgY2FsbGFibGUgZnVuY3Rpb25zIGFyZSBsb2NhdGVkIGluIChleDogdXMtY2VudHJhbDEpXHJcbiAqICAgYikgQSBjdXN0b20gZG9tYWluIGhvc3RpbmcgdGhlIGNhbGxhYmxlIGZ1bmN0aW9ucyAoZXg6IGh0dHBzOi8vbXlkb21haW4uY29tKVxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRGdW5jdGlvbnMoYXBwID0gZ2V0QXBwKCksIHJlZ2lvbk9yQ3VzdG9tRG9tYWluID0gREVGQVVMVF9SRUdJT04pIHtcclxuICAgIC8vIERlcGVuZGVuY2llc1xyXG4gICAgY29uc3QgZnVuY3Rpb25zUHJvdmlkZXIgPSBfZ2V0UHJvdmlkZXIoZ2V0TW9kdWxhckluc3RhbmNlKGFwcCksIEZVTkNUSU9OU19UWVBFKTtcclxuICAgIGNvbnN0IGZ1bmN0aW9uc0luc3RhbmNlID0gZnVuY3Rpb25zUHJvdmlkZXIuZ2V0SW1tZWRpYXRlKHtcclxuICAgICAgICBpZGVudGlmaWVyOiByZWdpb25PckN1c3RvbURvbWFpblxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBlbXVsYXRvciA9IGdldERlZmF1bHRFbXVsYXRvckhvc3RuYW1lQW5kUG9ydCgnZnVuY3Rpb25zJyk7XHJcbiAgICBpZiAoZW11bGF0b3IpIHtcclxuICAgICAgICBjb25uZWN0RnVuY3Rpb25zRW11bGF0b3IoZnVuY3Rpb25zSW5zdGFuY2UsIC4uLmVtdWxhdG9yKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbnNJbnN0YW5jZTtcclxufVxyXG4vKipcclxuICogTW9kaWZ5IHRoaXMgaW5zdGFuY2UgdG8gY29tbXVuaWNhdGUgd2l0aCB0aGUgQ2xvdWQgRnVuY3Rpb25zIGVtdWxhdG9yLlxyXG4gKlxyXG4gKiBOb3RlOiB0aGlzIG11c3QgYmUgY2FsbGVkIGJlZm9yZSB0aGlzIGluc3RhbmNlIGhhcyBiZWVuIHVzZWQgdG8gZG8gYW55IG9wZXJhdGlvbnMuXHJcbiAqXHJcbiAqIEBwYXJhbSBob3N0IC0gVGhlIGVtdWxhdG9yIGhvc3QgKGV4OiBsb2NhbGhvc3QpXHJcbiAqIEBwYXJhbSBwb3J0IC0gVGhlIGVtdWxhdG9yIHBvcnQgKGV4OiA1MDAxKVxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBjb25uZWN0RnVuY3Rpb25zRW11bGF0b3IoZnVuY3Rpb25zSW5zdGFuY2UsIGhvc3QsIHBvcnQpIHtcclxuICAgIGNvbm5lY3RGdW5jdGlvbnNFbXVsYXRvciQxKGdldE1vZHVsYXJJbnN0YW5jZShmdW5jdGlvbnNJbnN0YW5jZSksIGhvc3QsIHBvcnQpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBjYWxsYWJsZSBIVFRQUyB0cmlnZ2VyIHdpdGggdGhlIGdpdmVuIG5hbWUuXHJcbiAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHRyaWdnZXIuXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGh0dHBzQ2FsbGFibGUoZnVuY3Rpb25zSW5zdGFuY2UsIG5hbWUsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBodHRwc0NhbGxhYmxlJDEoZ2V0TW9kdWxhckluc3RhbmNlKGZ1bmN0aW9uc0luc3RhbmNlKSwgbmFtZSwgb3B0aW9ucyk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGNhbGxhYmxlIEhUVFBTIHRyaWdnZXIgd2l0aCB0aGUgc3BlY2lmaWVkIHVybC5cclxuICogQHBhcmFtIHVybCAtIFRoZSB1cmwgb2YgdGhlIHRyaWdnZXIuXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGh0dHBzQ2FsbGFibGVGcm9tVVJMKGZ1bmN0aW9uc0luc3RhbmNlLCB1cmwsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBodHRwc0NhbGxhYmxlRnJvbVVSTCQxKGdldE1vZHVsYXJJbnN0YW5jZShmdW5jdGlvbnNJbnN0YW5jZSksIHVybCwgb3B0aW9ucyk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxucmVnaXN0ZXJGdW5jdGlvbnMoZmV0Y2gsICdub2RlJyk7XG5cbmV4cG9ydCB7IGNvbm5lY3RGdW5jdGlvbnNFbXVsYXRvciwgZ2V0RnVuY3Rpb25zLCBodHRwc0NhbGxhYmxlLCBodHRwc0NhbGxhYmxlRnJvbVVSTCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@firebase+functions@0.11.8_@firebase+app@0.10.13/node_modules/@firebase/functions/dist/esm-node/index.node.esm.js\n");

/***/ })

};
;